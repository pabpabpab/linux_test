СОДЕРЖИМОЕ ФАЙЛА bash.sh
======================================================================
#!/bin/bash
echo //
echo //
echo //
echo //
echo //
echo //
echo //
echo //
echo //
echo //
echo //
echo //
echo //
echo //
echo // ЭТОТ ФАЙЛ ЗАПУЩЕН КОМАНДОЙ bash ./bash.sh из домашней папки
echo // Предварительно был удален старый rm bash.sh и создан новый nano bash.sh 
echo ==============================================
echo // создать директорию /tmp/lesson3/permissions
echo // mkdir -p /tmp/lesson3/permissions
mkdir -p /tmp/lesson3/permissions
echo ==============================================
echo // внутри директории создать 3 файла, 
echo // причем два из них это различного типа ссылки на предыдущий файл, 
echo // а у одного есть небольшое текстовое содержимое.
echo ==============================================
echo // создаю файл с текстовым содержимым 
echo // эхо hi there в /tmp/lesson3/permissions/file1.txt
echo "hi there" > /tmp/lesson3/permissions/file1.txt
echo ==============================================
echo // создаю хардлинк на файл file1.txt
echo // ln /tmp/lesson3/permissions/file1.txt /tmp/lesson3/permissions/file1_hardlink.txt
ln /tmp/lesson3/permissions/file1.txt /tmp/lesson3/permissions/file1_hardlink.txt
echo ==============================================
echo // создаю софтлинк на файл file1.txt
echo // ln -s /tmp/lesson3/permissions/file1.txt /tmp/lesson3/permissions/file1_softlink.txt
ln -s /tmp/lesson3/permissions/file1.txt /tmp/lesson3/permissions/file1_softlink.txt
echo ==============================================
echo // создать еще одну символическую ссылку в директории /tmp/lesson3/, 
echo // которая указывает на ранее созданную символическую ссылку:
echo // ln -s /tmp/lesson3/permissions/file1_softlink.txt /tmp/lesson3/file1_softlink_softlink.txt
ln -s /tmp/lesson3/permissions/file1_softlink.txt /tmp/lesson3/file1_softlink_softlink.txt
echo ==============================================
echo // вывести на экран метаданные всех созданных файлов, включая их inode:
echo // ls -lai /tmp/lesson3/permissions/file1* /tmp/lesson3/file1*
echo ----------------------------------------------
ls -lai /tmp/lesson3/permissions/file1* /tmp/lesson3/file1*
echo ----------------------------------------------
echo ==============================================
echo // вывести на экран содержимое только тех файлов, 
echo // которые могут его показать:  
echo // find /tmp/lesson3 -maxdepth 2 -size +0 -name 'file1*' -type f -print -exec cat {} \;
echo ----------------------------------------------
find /tmp/lesson3 -maxdepth 2 -size +0 -name 'file1*' -type f -print -exec cat {} \;
echo ----------------------------------------------
echo // как видим содержимое файла /критерий -size +0/ могут показать только хардлинки,
echo // символьные ссылки не содержат внутри себя содержимого самого файла. 
echo ==============================================
echo // Должны ли выведенные иноды совпадать или отличаться? Почему?:
echo // Иноды хардлинка и файла на который он указывает - одинаковые, 
echo // такова суть жестких ссылок. Поэтому жесткая ссылка имеет те же права доступа, 
echo // владельца и время последней модификации, что и целевой файл.
echo // Иноды софтлинка и файла на который они указывают - разные, 
echo // потому что символьный линк не ссылается на тот же inode, 
echo // у него есть только информация о названии файла на который он ссылается - путь. 
echo // Символьная ссылка может иметь права отличающиеся от файла на который она указывает.
echo ==============================================
echo // переместить обе ссылки /в моих ссылках есть символ '_', поэтому использую file1_*/ 
echo // из /tmp/lesson3/permissions в директорию /tmp
echo // mv /tmp/lesson3/permissions/file1_* /tmp
mv /tmp/lesson3/permissions/file1_* /tmp
echo ==============================================
echo // повторить предыдущий пункт и вывести метаданные с содержимым. 
echo // Работают все ссылки?
echo // т.е. вывести на экран матаданные всех созданных файлов, включая их иноды:
echo // ls -lai /tmp/lesson3/permissions/file1* /tmp/lesson3/file1* /tmp/file1*
echo ----------------------------------------------
ls -lai /tmp/lesson3/permissions/file1* /tmp/lesson3/file1* /tmp/file1*
echo ----------------------------------------------
echo // Видим что хардлинк работает, потому что он ссылается по inode файла. 
echo // Первый софтлинк также работает, потому что файл на который он ссылается 
echo // остался на прежнем месте, т.е. имя файла - его путь - остался прежним. 
echo // Второй софтлинк стал неработающим, потому что файл - первый софтлинк, 
echo // на который он ссылается - перенесен, по указанному пути нет больше файла.
echo // Вот только когда ls делается из bash.sh, то цветом неактивная ссылка не выделяется
echo // проверить вручную ls -lai /tmp/lesson3/file1_softlink_softlink.txt
echo ==============================================
echo // КОМАНДЫ ОЧИСТКИ СОЗДАННЫХ ФАЙЛОВ
echo // команда ниже выполнена не будет, но ее можно выполнить вручную
echo // rm /tmp/lesson3/permissions/file1* /tmp/lesson3/file1* /tmp/file1*
echo // и еще в эхо звездочки обрабатываются, и вместо них выводятся полные имена файлов




ВЫВОД bash.sh
============================================================================================
//
//
//
//
//
//
//
//
//
//
//
//
//
//
// ЭТОТ ФАЙЛ ЗАПУЩЕН КОМАНДОЙ bash ./bash.sh из домашней папки
// Предварительно был удален старый rm bash.sh и создан новый nano bash.sh
==============================================
// создать директорию /tmp/lesson3/permissions
// mkdir -p /tmp/lesson3/permissions
==============================================
// внутри директории создать 3 файла,
// причем два из них это различного типа ссылки на предыдущий файл,
// а у одного есть небольшое текстовое содержимое.
==============================================
// создаю файл с текстовым содержимым
// эхо hi there в /tmp/lesson3/permissions/file1.txt
==============================================
// создаю хардлинк на файл file1.txt
// ln /tmp/lesson3/permissions/file1.txt /tmp/lesson3/permissions/file1_hardlink.txt
==============================================
// создаю софтлинк на файл file1.txt
// ln -s /tmp/lesson3/permissions/file1.txt /tmp/lesson3/permissions/file1_softlink.txt
==============================================
// создать еще одну символическую ссылку в директории /tmp/lesson3/,
// которая указывает на ранее созданную символическую ссылку:
// ln -s /tmp/lesson3/permissions/file1_softlink.txt /tmp/lesson3/file1_softlink_softlink.txt
==============================================
// вывести на экран метаданные всех созданных файлов, включая их inode:
// ls -lai /tmp/lesson3/permissions/file1_hardlink.txt /tmp/lesson3/permissions/file1_softlink.txt /tmp/lesson3/permissions/file1.txt /tmp/lesson3/file1_softlink_softlink.txt
----------------------------------------------
1177748 lrwxrwxrwx 1 alexp alexp 43 мая 10 18:52 /tmp/lesson3/file1_softlink_softlink.txt -> /tmp/lesson3/permissions/file1_softlink.txt
1177744 -rw-r--r-- 2 alexp alexp  9 мая 10 18:52 /tmp/lesson3/permissions/file1_hardlink.txt
1177745 lrwxrwxrwx 1 alexp alexp 34 мая 10 18:52 /tmp/lesson3/permissions/file1_softlink.txt -> /tmp/lesson3/permissions/file1.txt
1177744 -rw-r--r-- 2 alexp alexp  9 мая 10 18:52 /tmp/lesson3/permissions/file1.txt
----------------------------------------------
==============================================
// вывести на экран содержимое только тех файлов,
// которые могут его показать:
// find /tmp/lesson3 -maxdepth 2 -size +0 -name file1* -type f -print -exec cat {} ;
----------------------------------------------
/tmp/lesson3/permissions/file1.txt
hi there
/tmp/lesson3/permissions/file1_hardlink.txt
hi there
----------------------------------------------
// как видим содержимое файла /критерий -size +0/ могут показать только хардлинки,
// символьные ссылки не содержат внутри себя содержимого самого файла.
==============================================
// Должны ли выведенные иноды совпадать или отличаться? Почему?:
// Иноды хардлинка и файла на который он указывает - одинаковые,
// такова суть жестких ссылок. Поэтому жесткая ссылка имеет те же права доступа,
// владельца и время последней модификации, что и целевой файл.
// Иноды софтлинка и файла на который они указывают - разные,
// потому что символьный линк не ссылается на тот же inode,
// у него есть только информация о названии файла на который он ссылается - путь.
// Символьная ссылка может иметь права отличающиеся от файла на который она указывает.
==============================================
// переместить обе ссылки /в моих ссылках есть символ _, поэтому использую file1_*/
// из /tmp/lesson3/permissions в директорию /tmp
// mv /tmp/lesson3/permissions/file1_hardlink.txt /tmp/lesson3/permissions/file1_softlink.txt /tmp
==============================================
// повторить предыдущий пункт и вывести метаданные с содержимым.
// Работают все ссылки?
// т.е. вывести на экран матаданные всех созданных файлов, включая их иноды:
// ls -lai /tmp/lesson3/permissions/file1.txt /tmp/lesson3/file1_softlink_softlink.txt /tmp/file1_hardlink.txt /tmp/file1_softlink.txt
----------------------------------------------
1177744 -rw-r--r-- 2 alexp alexp  9 мая 10 18:52 /tmp/file1_hardlink.txt
1177745 lrwxrwxrwx 1 alexp alexp 34 мая 10 18:52 /tmp/file1_softlink.txt -> /tmp/lesson3/permissions/file1.txt
1177748 lrwxrwxrwx 1 alexp alexp 43 мая 10 18:52 /tmp/lesson3/file1_softlink_softlink.txt -> /tmp/lesson3/permissions/file1_softlink.txt
1177744 -rw-r--r-- 2 alexp alexp  9 мая 10 18:52 /tmp/lesson3/permissions/file1.txt
----------------------------------------------
// Видим что хардлинк работает, потому что он ссылается по inode файла.
// Первый софтлинк также работает, потому что файл на который он ссылается
// остался на прежнем месте, т.е. имя файла - его путь - остался прежним.
// Второй софтлинк стал неработающим, потому что файл - первый софтлинк,
// на который он ссылается - перенесен, по указанному пути нет больше файла.
// Вот только когда ls делается из bash.sh, то цветом неактивная ссылка не выделяется
// проверить вручную ls -lai /tmp/lesson3/file1_softlink_softlink.txt
==============================================
// КОМАНДЫ ОЧИСТКИ СОЗДАННЫХ ФАЙЛОВ
// команда ниже выполнена не будет, но ее можно выполнить вручную
// rm /tmp/lesson3/permissions/file1.txt /tmp/lesson3/file1_softlink_softlink.txt /tmp/file1_hardlink.txt /tmp/file1_softlink.txt
// и еще в эхо звездочки обрабатываются, и вместо них выводятся полные имена файлов





БИТ SetGID
=================================================================================
бит SetGID влияет на то с какими правами будет запущен исполняемый файл, 
или на то с какими правами будут запущены файлы в каталоге с установленным битом SetGID

Расположение бита SetGID в правах доступа
-----------------------------------------------
SetUID SetGID sticky-бит | user | group | other
4      2      1          | r w x| r w x | r w x 
-----------------------------------------------
Восьмеричное значение для SetGID - 2000.


Когда пользователь или процесс запускает исполняемый файл с установленным битом SetGID, файлу временно назначаются права его (файла) группы. Таким образом, пользователь может даже запускать файлы от имени суперпользователя.


Применение SetGID на практике
----------------------------------------------
1) Если установить SetGID для каталога, и если пользователь поместил исполняемый файл в такой каталог, запустив его, процесс запустится от имени владельца (группы) каталога, в котором лежит этот файл. Таким образом, пользователь может например даже запускать файлы от имени суперпользователя.


2) Когда бит установлен для каталога, набор файлов в этом каталоге будет иметь ту же группу, что и группа родительского каталога, а не группы пользователя, создавшего эти файлы. Это используется для общего доступа к файлам, поскольку теперь они могут быть изменены всеми пользователями, входящими в группу родительского каталога.
----------------------------------------------


Установить SetGID можно командой chmod:
chmod g+s имя_файла_или_папки,
или например команда: 
chmod 2755 имя_файла_или_папки
устанавливает на файл_или_папку бит SGID и заменяет обычные права на 755.

После установки бита SetGID и просмотра метаданных командой ls -l, бит SetGID отмечается буквой "s" на месте бита "x" для group





ИЗМЕНИТЬ ВЛАДЕЛЬЦА И ГРУППУ У ФАЙЛА ИЛИ ПАПКИ
=================================================================================
sudo chown -R user:group /home/user/dir/






NODE.js
=================================================================================

создаю папку куда буду клонировать node.js
sudo mkdir /opt/node.js/

укажу группу папки как root, а владельцем себя
sudo chown alexp:root /opt/node.js/

установлю бит SetGID для папки /node.js, с тем умыслом что любой пользователь сможет запустить node.js из нее как root (то есть с правами группы папки, а группа папки уже установлена как root)
sudo chmod 2755 /opt/node.js

клонирую node 
git clone git@github.com:nodejs/node.git /opt/node.js/


установить компилятор и необходимые зависимости
-----------------------------------------------
gcc -v // gcc version 7.5.0
make -v // GNU Make 4.1
sudo apt update
sudo apt install python3.6
python3 --version // Python 3.6.9
sudo apt-get install python3-distutils
cd /opt/node.js/
./configure
make -j4 // за 1.5 часа скомпилировалось


Проверка работы node.js
./node -e "console.log('Hello from Node.js ' + process.version)"
есть ответ
Hello from Node.js v15.0.0-pre



Укажу доп путь для поиска бинарных файлов через переменную кружения PATH
export PATH=/opt/node.js:$PATH
ввожу для проверки из домашней папки
node
работает, выводится 
Welcome to Node.js v15.0.0-pre.
или это 
node -e "console.log('Hello from Node.js ' + process.version)"
выводится 
Hello from Node.js v15.0.0-pre


чтобы при старте шелла переменная PATH была уже расширена, 
отредактирую файл ~/.bashrc - допишу в конце
export PATH=/opt/node.js:$PATH
добавлю этому файлу права на выполнение
chmod u+x ~/.bashrc


exit
запуск терминала
проверка
node
работает


